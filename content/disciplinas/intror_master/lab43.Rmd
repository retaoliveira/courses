---
title: "Lab 4.3"
draft: no
date: '2021-10-15T00:00:00+01:00'
menu:
  intror_master:
    parent: Unidade 4
    weight: 20
toc: yes
type: docs
weight: 20
---
```{r load-pkg, message = FALSE}
library(tidyverse)
```

# Recuperando ambiente da sessão anterior

```{r eval=FALSE, message=FALSE, warning=FALSE, include=TRUE}
            #---
    getwd() # O diretório de trabalho é ...
            #---

    #---
    # se necessário use o comando ...
    #
    #       setwd   [ver exemplo de uso no help]
    #
    # ... para mudar ou definir o diretorio de trabalho
    #---

    #---
    #
    #   carga de variaveis, funções, etc, da sessão anterior,
    #   que havíamos armazenado no ARQUIVO ProjetoIniAmbiente.RData
    #
    #---

      load("ProjetoIniAmbiente.RData") 

```


# Matrizes: vetores especiais

## Basics

```{r eval=FALSE, message=FALSE, warning=FALSE, include=TRUE}
        matrix( data= 1:20, nrow= 4)
        matrix( data= 1:20, nrow= 5)
        matrix( data= 1:20, 4)
        matrix( data= 1:20, ncol= 4)
        matrix( data= 1:20, , 4)
  
      #---
      # OBS IMPORTANTE: ordem DEFAULT de preenchimento: por coluna 
      #---
  
        mA= matrix( data= 1:20, nrow= 4, byrow= T)
          mA
  
      #---
      # Reconciliando: a operação transposição 
      #---
  
        t(mA)
  
      #---
      # Matrizes de caracteres  ... 
      #---
      
        mChar= matrix( data= month.abb, nrow= 4)
      
      #---
      # ... ou de logicos 
      #---
      
        vTemp= ((1:12)%%4) == 1
          mLog= matrix( vTemp, nrow= 4)
          mLog
      
          #---
          # + direto: 
          #---
          
            matrix( ((1:12)%%4) == 1,  4)
  
      #---
      #
      #   OBS Elementos de uma matriz sempre têm mesmo tipo. 
      #       Se não for assim são modificados! 
      #       Na marra e na surdina.
      #
      #---
  
        matrix( c(1:10,T,T),  4)
        matrix( c(1:10,"T",T),  4)
        
```

## Operações elementares I: Matrizes e Escalares
```{r eval=FALSE, message=FALSE, warning=FALSE, include=TRUE}
  mA
        2*mA
        sqrt(mA)
        mA^(1/3)
        2^mA
        mA>5
        paste(mA, "1")
        c(mA, "1")
        c(mA, 1)
  
```

## Operações elementares II: Matrizes e Vetores
```{r eval=FALSE, message=FALSE, warning=FALSE, include=TRUE}
        mA= t(mA)
        mA
                    #---
        mA + 1:20   # Business as usual
                    #---
  
                    #---
        mA + 1:10   # 2 {length(mA) / length(1:10) } Ciclos
                    #---
  
                    #---
        mA + 1:16   # Numero não inteiro de ciclos
                    #---
          1:20+1:16
          matrix( 1:20+1:16, 5 )
  
      #---
      # outro exemplo de ciclo
      #---
        mB= matrix( 1:12, 4 )
        (1:3)^mB
```

## Operações elementares III: Matrizes e Matrizes
```{r eval=FALSE, message=FALSE, warning=FALSE, include=TRUE}
        mB
        mA
        mA + mB
    
        mA= matrix(1:16, 4)
        mC= matrix(1:8, 4)
          mA+mC
  
      #---
      # Produto matricial
      #---
    
        dim(mA)
        dim(mB)
          mA%*%mB
  
      #---
      # Inversa
      #---
  
        solve(mA)
        set.seed(1)
          mD= matrix(runif(16), 4)
          solve(mD)
        mD %*% solve(mD)
        round(mD %*% solve(mD), digits=6)
```

## Submatrizes , etc
```{r eval=FALSE, message=FALSE, warning=FALSE, include=TRUE}
        mA
            mA[1,3]         # elemento [1,3]
            mA[2,]          # segunda linha
            mA[1:2,]        # primeira e segunda linhas
            mA[,c(1,3)]     # primeira e terceira colunas
            mA[1:2,c(1,3)]  # Uma SubMatriz
  
      #---
      # Lembrando subvetores
      #---
        y= 10*(1:11)
          length(y)
          y
          ehPar= c(F, T, F, T, F, T, F, T, F, T, F)
          y[ehPar]
          ehPar= ((1:length(y))%%2 == 0)
  
      #---
      # Análogo pra formação de submatrizes
      #---
        mD= round(100*mD, 0)
            row(mD)
            col(mD)
          LinMaiorQCol= row(mD)>col(mD)
        mD[LinMaiorQCol]
        mD
        mD[row(mD)==col(mD)]
```

## Documentando vetores 
```{r eval=FALSE, message=FALSE, warning=FALSE, include=TRUE}
    
        y=1:12
        names(y)= month.abb
        y
        y[c(2,4)]
        y[c("Jan", "Feb", "Jul")]
    
```

## Documentando matrizes 
```{r eval=FALSE, message=FALSE, warning=FALSE, include=TRUE}
        mA= matrix(1:20, 5)
        dimnames(mA)= list(letters[1:5],month.abb[1:4])
        mA
        
        summary(matrix(1:20, 5))
        summary(mA)
```


## Listas: uma estrutura mais geral
```{r eval=FALSE, message=FALSE, warning=FALSE, include=TRUE}
  dadosDeGB= 
    list( nome="Giordanno Bruno",
          idade= 48,
          ehCasado= F,
          numerosPreferidos= c(pi, log(10)))

    #---
    # Obs:  Ao contrário de vetores e matrizes, 
    #       NÃO é necessário que todas as componentes 
    #       sejam de mesmo tipo
    #---

  #---
  # recuperando componentes
  #---

    dadosDeGB[[2]] 
    dadosDeGB$nome 
    dadosDeGB["nome"] 
    dadosDeGB[c("nome","idade")] 

                      #---
    dadosDeGB[[1:2]]  # <=== Isso não dá pra fazer
                      #---

  #---
  # incorporando componentes
  #---
    names(dadosDeGB)
    dadosDeGB$anosDeEstudo= 40
    names(dadosDeGB)


```

## LGN & TCL : exercícios de simulação e a função apply

### EX 1: yBarra converge para Valor Esperado de Y 
```{r eval=FALSE, message=FALSE, warning=FALSE, include=TRUE}
    set.seed(1)
    smpSize= 50000
    y= rpois(smpSize, lambda=.8)
    vyBarra= cumsum(y)/1:smpSize

    plot(1:smpSize, vyBarra, ylim= c(.75,.85),
         type= "b", pch=15, cex=.5,
         xlab= "tamanho de amostra",
         main= paste("Evolução das médias aritméticas de Poi(.8)\n",
                     "com o tamanho da amostra") )
      abline(h=.8, col="red")
```


### EX 2: yBarra não converge para Valor Esperado de Y 
```{r eval=FALSE, message=FALSE, warning=FALSE, include=TRUE}
    set.seed(2)
    smpSize= 50000
    y= rcauchy(smpSize)
    vyBarra= cumsum(y)/(1:smpSize)
    
    plot(1:smpSize, vyBarra,  #ylim= c(.75,.85),
         type= "b", pch=15, cex=.5,
         main= paste("Evolução das médias aritméticas de Cauchys\n",
                     "com o tamanho da amostra"),
         xlab="tamanho de amostra")
    abline(h=0, col="red")
```

### EX 3: n^(1/2)(yBarra - mu)/sigma converge em distribuição para Z 
```{r eval=FALSE, message=FALSE, warning=FALSE, include=TRUE}
    set.seed(1)
      smpSize= 500
      nReplic= 400

    mYs= matrix( rexp(smpSize*nReplic), smpSize)
    vDeYbarras= apply(mYs, 2, mean)

    plot(density(sqrt(smpSize)*(vDeYbarras-1), bw="SJ"), 
         main="Densidade Estimada vs Normal")
      lines( seq(-3,3,,50), dnorm(seq(-3,3,,50)),
             col="red")
```


### EX 4: n^(1/2)(yBarra - mu)/s converge em distribuição para Z 
```{r eval=FALSE, message=FALSE, warning=FALSE, include=TRUE}
    set.seed(1)
      smpSize= 800
      nReplic= 2000
    
    mYs= matrix( rexp(smpSize*nReplic), smpSize)
      vDeYbarras= apply(mYs, 2, mean)
    #---
    # Equivalente mas mais lento:
    #   
    #   vDeYbarras= rep(0, ncol(mYs)) 
    #   for(j in 1:ncol(mYs)) {
    #     vDeYbarras[j]= mean(mYs[,j])   
    #   }
    #---
      vDeSs= apply(mYs, 2, sd)
    
    plot(density(sqrt(smpSize)*(vDeYbarras-1)/vDeSs, bw="SJ"), 
         main="Densidade Estimada vs Normal")
    lines( seq(-3,3,,50), dnorm(seq(-3,3,,50)),
           col="red")
```


### EX 5: Just for fun
```{r eval=FALSE, message=FALSE, warning=FALSE, include=TRUE}
     lix=   seq(-pi,pi,,2^13)
      plot(  2^.5*cos(lix)/(1 + sin(lix)^2),
             2^.5*sin(lix)*cos(lix)/(1 + sin(lix)^2),
             type="l", xlab="", ylab="",
             main= "A Lemniscata de Jacobo Bernoulli",
             col= rgb( .95, .55, .55),
             col.main="blue", axes=F)
      nCurv= 16
      escala= seq(1, .95, , nCurv)
      for(   knd in 2:nCurv  ) {
        lines( escala[knd]*2^.5*cos(lix)/(1 + sin(lix)^2),
               escala[knd]*2^.5*cos(lix)*sin(lix)/(1 + sin(lix)^2),
               col=
                 rgb( .95,
                      .3+.25*knd/(1+nCurv),
                      .3+.25*knd/(1+nCurv) ),
               lwd=3) }
```


## Dataframes: meio listas e meio matrizes
### Importando dados
```{r eval=FALSE, message=FALSE, warning=FALSE, include=TRUE}
    #---
    #   Um exemplo
    #
    #
    #   1.  dados usados em Stock & Watson
    #
    #   2.  http://wps.aw.com/aw_stock_ie_2/50/13016/3332253.cw/index.html
    #
    #   3.  Baixar os dois arquivos relativos a
    #
    #           "California Test Score Data Used in Chapters 4-9"
    #
    #       no diretório do projeto em q vc está trabalhando.
    #
    #   4.  Um deles: formato= XL [extensão= .xls]; 
    #           o outro: formato = STATA [extensão= .dta]
    #
    #   5.  Edite o caschool.xls e salve como formato csv
    #---

    dFCaschool= read.csv2(file="caschool.csv")
      head(dFCaschool)
      tail(dFCaschool)

    #--- Equivalente: Lendo direto no formato do STATA 
    #
    # dFCaschool= read.dta("caschool.dta")
    #
    #--- 

    is.matrix(dFCaschool)
    is.list(dFCaschool)

    is.data.frame(dFCaschool)
      names(dFCaschool)

    dFNerlove= read.csv2("nerlove.csv")
      head(dFNerlove)
```
  
## Exercício de simulação 

```{r eval=FALSE, message=FALSE, warning=FALSE, include=TRUE}
#   i.    modelo: Y = beta1 + beta2*X + Eps com xNobs observações
#
#   ii.   simulo: xB realizações do processo acima
#
#   iii.  para cada uma das realizações estime beta via OLS.
#         use a função lsfit
#
#   iv.   estime a densidade de beta2Hat e a variância de beta2Hat
# 
#   v.    faça boxplot dos beta2Hat's
#
#   vi.   Considere o estimador:
#            
#         beta2Til= Média Aritmética ponderada de
#
#           { (Y1-YBarra)/(X1-XBarra), ..., (Yn-YBarra)/(Xn-XBarra)}, 
#
#               com pesos
#
#           { |X1-XBarra|, ..., |Xn-XBarra|}, 
#
#         beta1Til= YBarra - beta2Til * XBarra
#
#   vii.  estime a densidade de beta2Til e a variância de beta2Til
#
#---

#---
# atribuo parametros
#---
  vBeta= c(1, .3)
  xNobs= 32
  xB=500
  set.seed(1)

#---
# a simulação ...
#---
  vRegX=  matrix(rnorm(xB*xNobs, mean= 4, sd=.5), 32)
  vEps=   matrix(rnorm(xB*xNobs, mean= 0, sd=.1), 32)
    vY= vBeta[1] + vBeta[2]*vRegX + vEps

#---
# só pra checar ...
#---
  plot(vRegX[,1], vY[,1])
  lsfit(vRegX[,1], vY[,1])
    lsfit(vRegX[,1], vY[,1])$coefficients

#---
# acumulo em mBetaHats os estimadores de OLS: 
#
#     primeiro reservo espaço pros estimadores ... 
#---
  mBetaHats= matrix(0, 2, 500)
    dimnames(mBetaHats)= 
        list( paste("BetaHat", 1:2, sep= ""),
              paste("Smpl", 1:500, sep= ""))

#---
#     a estimação propriamente dita ... 
#---
  for(n in 1:xB){
    mBetaHats[,n]= lsfit(vRegX[,n], vY[,n])$coefficients
  }
  boxplot(mBetaHats["BetaHat2",])  
  sd(mBetaHats["BetaHat2",])

#---
# acumulo em mBetaTildas os estimadores alternativos: 
#
#     primeiro reservo espaço pros estimadores ... 
#---
  mBetaTildas= matrix(0, 2, 500)
  dimnames(mBetaTildas)= 
    list( paste("BetaTilda", 1:2, sep= ""),
          paste("Smpl", 1:500, sep= ""))

#---
#     a estimação propriamente dita ... 
#---
  for(n in 1:xB){
    ybarTmp= mean(vY[,n])
    xbarTmp= mean(vRegX[,n])
    mBetaTildas[2,n]= 
      weighted.mean((vY[,n]-ybarTmp)/(vRegX[,n]-xbarTmp),
                    abs(vRegX[,n]-xbarTmp) )
    mBetaTildas[1,n]=
      ybarTmp - mBetaTildas[2,n]*xbarTmp
  }

  boxplot(mBetaTildas["BetaTilda2",])  
  sd(mBetaTildas["BetaTilda2",])

```

## Salvando o ambiente
```{r eval=FALSE, message=FALSE, warning=FALSE, include=TRUE}
    save.image(file="EnvironmentPrjt1.RData")

```
